############################################################
# samples/makefile.nvmk
#
# Top level makefile for samples. Defines all the include
# directories. Each individual sample nvmakefile will determine source
# names and executable names

include $(NV_SOURCE)/common/build/nvCommon.nvmk

# Used for building CUDA source files. This can go away if CUDA
# support gets added to the nvmake standard library.
include $(NV_SOURCE)/nvmake/hacks-for-nvmake-standard-library.nvmk

ifeq ($(findstring $(NV_BUILD_TYPE),"debug release"),)
  $(error Only release and debug builds are supported)
endif

ifeq ($(findstring $(NV_TARGET_ARCH),"amd64"),)
  $(error Only x64 (a.k.a amd64) target architecture is supported)
endif

# Only WDDM versions of Windows OS are supported
ifneq ($(NV_IS_WDDM),1)
  $(error Unsupported NV_TARGET_OS $(NV_TARGET_OS). Linux support is planned but not implemented yet.)
endif

include $(NV_COMMON)/build/nvconfig.nvmk
ifdef NVCFG_INITIALIZED

  ############################################################
  # Toolchain (compiler, ddk)

  # workaround an issue where NVCC seesm to require the use of -Zi,
  # and seems to be incompatible with the use of -Z7.
  #
  # This WAR could maybe be removed if switch from -Zi to -Z7. But
  # NVCC seems to hard-code -Zi and be incompatible with using -Z7.
  workaround_nvcc_pdb_issue = 1

  # NVCC misbehaves. Do this always in order to placate NVCC
  ifeq ($(NV_SYMBOLS),1)
    # This causes nvmake standard library to add -Zi to CFLAGS. Set this
    # before including makefile-tools-*.nvmk.
    NV_SYMBOLS_PDB = 1
  else ifeq ($(workaround_nvcc_pdb_issue),1)
    # Set it anyway to placate NVCC
    NV_SYMBOLS_PDB = 1
  endif

  include $(NV_SOURCE)/nvmake/makefile-tools-$(NV_TARGET_OS_FAMILY).nvmk

  # Set up things relevant to the nvmake-based makefiles.
  include $(NV_SOURCE)/nvmake/makefile-config.nvmk

  # Cause make to generate a useful error diagnostic if one of the
  # include paths is missing from local disk.
  NV_REQUIRED_DIRS += $(NV_INCLUDES)

  ############################################################
  # CRT

  ifeq ($(NV_TARGET_OS_FAMILY),Windows)

    NV_WIN_USES_CRT = 1
    # NV_WIN_USES_VCRT = 1
    # NV_WIN_USES_UCRT = 1
    # NV_WIN_USES_CPRT = 1
    include $(NV_COMMON)/build/nvWindowsCRT.nvmk

    # The following flags replicate the CRT flags used for c/cpp file compilation
    NVCC_FLAGS += --compiler-options $(NV_WINCRT_CFLAGS)
  endif

  ############################################################
  # C++ compiler flags

  # Initially, ignore precompiled headers. See display driver
  # makefiles for example of how to use precompiled headers from
  # nvmake-based makefiles.
  PCH_EXCLUSIONS += $(SOURCES)
  $(call BUILD_OBJECT_LIST,$(PCH_EXCLUSIONS)): NV_NO_PCH := 1

  ifeq ($(NV_TARGET_OS_FAMILY),Windows)

    # Enable C++ exceptions (https://docs.microsoft.com/en-us/cpp/cpp/cpp-exception-handling)
    SAMPLES_CFLAGS += -EHsc

    ifeq ($(NV_BUILD_TYPE),debug)
      # Report variable use without initialization
      SAMPLES_CFLAGS += -RTCu

      # Stack frame run-time error checking
      SAMPLES_CFLAGS += -RTCs

      # Detect assignments that result in data loss
      #SAMPLES_#CFLAGS += -RTCc

      # Buffer security check
      SAMPLES_CFLAGS += -GS
    else
      # Link-time code generation
      NV_LTCG = 1
    endif

    ifeq ($(NV_SYMBOLS)_$(NV_SYMBOLS_PDB),1_1)
      SAMPLES_CFLAGS += -FS
      SAMPLES_CFLAGS += -Fd$(OUTPUTDIR)/
    else ifeq ($(workaround_nvcc_pdb_issue),1)
      # NVCC misbehaves. Do this always in order to placate NVCC
      SAMPLES_CFLAGS += -FS
      SAMPLES_CFLAGS += -Fd$(OUTPUTDIR)/
    endif

  endif

  ############################################################
  # Build lists of SOURCES and OBJECTS and targets

  include $(NV_SOURCE)/samples/makefile-samples.nvmk

  targetList += $(SAMPLES_TARGETS)

  # Automatically rebuild after changing this makefile
  $(OBJECTS): $(NV_SOURCE)/samples/makefile.nvmk
  $(targetList): $(NV_SOURCE)/samples/makefile.nvmk

  ifeq ($(workaround_nvcc_pdb_issue),1)
    # Workaround linker reading from a pdb while compiler is writing
    # to it.
    $(targetList): | $(OBJECTS)
  endif

  ############################################################
  # Targets

  build:: $(NV_REQUIRED_DIRS) $(targetList)

  $(NV_INSTALL_DIR)/%.exe: $(OUTPUTDIR)/%.exe
	$(standard_install)

  $(NV_INSTALL_DIR)/%.dll: $(OUTPUTDIR)/%.dll
	$(standard_install)

  $(NV_INSTALL_DIR)/%.lib: $(OUTPUTDIR)/%.lib
	$(standard_install)

  $(NV_SYMBOL_DIR)/%.pdb: $(OUTPUTDIR)/%.pdb
	$(standard_install)

  $(NV_SYMBOL_DIR)/%.map: $(OUTPUTDIR)/%.map
	$(standard_install)

endif # NVCFG_INITIALIZED

include $(NV_COMMON)/build/nvCommonRules.nvmk
